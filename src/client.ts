/**
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2025 Adobe All Rights Reserved.
 *
 * NOTICE: All information contained herein is, and remains the property of Adobe and its suppliers, if any. The
 * intellectual and technical concepts contained herein are proprietary to Adobe and its suppliers and are protected by
 * all applicable intellectual property laws, including trade secret and copyright laws. Dissemination of this
 * information or reproduction of this material is strictly forbidden unless prior written permission is obtained from
 * Adobe.
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech) using custom templates.
 * Generator configuration can be found in the /generator directory.
 *
 * Do not edit this file manually!
 */

import { createHttpClient } from './http-client';
import {
  ClientConfig,
  FeedMetadata,
  FeedMetadataDelete,
  FeedMetadataUpdate,
  FeedPricebook,
  FeedPrices,
  FeedPricesDelete,
  FeedPricesUpdate,
  FeedProduct,
  FeedProductDelete,
  FeedProductUpdate,
  ProcessFeedResponse,
} from './types';
import { createAuthService } from './auth';
import { config } from 'dotenv';

export interface Client {
  /**
   * Create product attribute metadata. To ensure product data is indexed for discovery, create or replace existing
   * product attribute metadata resources before creating products. For each Commerce project, you must define metadata
   * for the following attributes for each scope (`locale`): - `sku` - `name` - `description` - `shortDescription` -
   * `price` Also, you can define metadata for custom attributes. When creating product attribute metadata: - Each
   * product attribute requires a unique `code` and `scope`. - Use the `dataType` field to define the data type for the
   * product attribute. - Use the `visibleIn` field to define where the product attribute is displayed on the
   * storefront. - Use the `filterable`, `sortable`, and `searchable` fields to define how the product attribute is used
   * for filtering, sorting, and searching. - Use the `searchWeight` field to define the search weight for the product
   * attribute. - Use the `searchTypes` field to define the search type for the product attribute. To update existing
   * product attribute metadata, use the update operation.
   *
   * @param data - Array<FeedMetadata> payload
   * @returns {Promise<ProcessFeedResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  createProductMetadata(data: Array<FeedMetadata>): Promise<ProcessFeedResponse>;
  /**
   * Delete product attributes metadata. Remove product attribute metadata resources from the catalog data.
   *
   * @param data - Array<FeedMetadataDelete> payload
   * @returns {Promise<ProcessFeedResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  deleteProductMetadata(data: Array<FeedMetadataDelete>): Promise<ProcessFeedResponse>;
  /**
   * Update product attribute metadata. Update existing product attribute metadata with new values. When the update is
   * processed, the merge strategy is used to apply changes to `scalar` and `object` type fields. The replace strategy
   * is used to apply changes for fields in an `array`.
   *
   * @param data - Array<FeedMetadataUpdate> payload
   * @returns {Promise<ProcessFeedResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  updateProductMetadata(data: Array<FeedMetadataUpdate>): Promise<ProcessFeedResponse>;
  /**
   * Create price books. Create or replace existing price books. Use the update operation to modify values for existing
   * price books.
   *
   * @param data - Array<FeedPricebook> payload
   * @returns {Promise<ProcessFeedResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  createPriceBooks(data: Array<FeedPricebook>): Promise<ProcessFeedResponse>;
  /**
   * Delete price books. Delete existing price books. When you delete a price book, all associated prices assigned to
   * the `priceBookId` are also deleted. If a product does not have any other price books assigned, the prices default
   * to the pricing schedule defined in the default, `main` price book. Note that you cannot delete the default price
   * book with id `main`.
   *
   * @param data - Array<FeedPricebook> payload
   * @returns {Promise<ProcessFeedResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  deletePriceBooks(data: Array<FeedPricebook>): Promise<ProcessFeedResponse>;
  /**
   * Update price books. Update existing price books to change the name or the currency used for pricing. When the
   * update is processed, the merge strategy is used to apply changes to `scalar` and `object` type fields. The replace
   * strategy is used to apply changes for fields in an `array`. To update the currency for the default price book, use
   * the price book id `main`.
   *
   * @param data - Array<FeedPricebook> payload
   * @returns {Promise<ProcessFeedResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  updatePriceBooks(data: Array<FeedPricebook>): Promise<ProcessFeedResponse>;
  /**
   * Create prices.<h3>Simple Products</h3> Create or replace existing product prices. A price must be associated with
   * at least the default price book with id `main`. <h3>Configurable Products</h3> Because configurable product price
   * is calculated based on the price of the selected product variant, you don't need to send price data for
   * configurable product skus. Sending price data for these skus can cause incorrect price calculations.
   *
   * @param data - Array<FeedPrices> payload
   * @returns {Promise<ProcessFeedResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  createPrices(data: Array<FeedPrices>): Promise<ProcessFeedResponse>;
  /**
   * Delete prices. Delete existing product prices
   *
   * @param data - Array<FeedPricesDelete> payload
   * @returns {Promise<ProcessFeedResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  deletePrices(data: Array<FeedPricesDelete>): Promise<ProcessFeedResponse>;
  /**
   * Update prices. Change existing product prices. When the update is processed, the merge strategy is used to apply
   * changes to `scalar` and `object` type fields. The replace strategy is used to apply changes for fields in an
   * `array`.
   *
   * @param data - Array<FeedPricesUpdate> payload
   * @returns {Promise<ProcessFeedResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  updatePrices(data: Array<FeedPricesUpdate>): Promise<ProcessFeedResponse>;
  /**
   * Create or replace products You can create different types of products, such as simple products and configurable
   * products. When creating products: - Each product requires a unique SKU identifier. - Products must have a defined
   * scope, for example `locale`. - Add values for the required `name`, `slug`, and `status` fields. - Define optional
   * fields such as descriptions, images, and custom attributes as needed. - Use the `links` field to define
   * relationships between products, such as linking a product variant to its parent configurable product. - You can
   * create multiple products in a single request, and also create product variants for configurable products in the
   * same request. <h3>Simple Products</h3> Create products or replace existing products with a specified `sku` and
   * `scope`. If a product with the same data exists with the same SKU and scope, the product update request is ignored.
   * Use the [update operation](#operation/ProductsPatch) to modify values for an existing product. <h3>Configurable
   * Products</h3> A configurable product is a product that offers multiple options, such as color and size. Each unique
   * combination of these options, like 'color green' and 'size large,' defines a product variant. This variant is an
   * independent product with its own SKU, price, and inventory. The configurable product acts as a container for these
   * product variants. To create a configurable product, you need the following: - [Product
   * attributes](#operation/ProductMetadataPut): Define the product attributes used to define a configurable product,
   * such as "color", "size", etc. - [Configurable product](#operation/ProductsPost): Define the configurable product.
   * [Configurations](#operation/ProductsPost!path=configurations&t=request) is a required field. It defines the choices
   * that a shopper can select. - [Product variant](#operation/ProductsPost): Define a product variant for a
   * configurable product. ["Attributes"](#operation/ProductsPost!path=attributes) with
   * ["variantReferenceId"](#operation/ProductsPost!path=attributes/variantReferenceId&t=request) and
   * ["links"](#operation/ProductsPost!path=links&t=request) of type `VARIANT_OF` must be defined for product variants.
   * Each product variant links back to the configurable product through its `variantReferenceId`, which corresponds to
   * specific `configurations[].values[].variantReferenceId` in the configurable product. To unassign a product variant
   * from a configurable product, do one of the following: - Use [Delete Product API](#operation/ProductsDelete) to
   * delete the product variant. - Use [Update Product API](#operation/ProductsPatch) to set the
   * ["variantReferenceId"](#operation/ProductsPost!path=attributes/variantReferenceId&t=request) to `null` and unassign
   * the product variant from the configurable product by removing the
   * ["links"](#operation/ProductsPost!path=links&t=request) association. <h3>Bundle Products</h3> A bundle product
   * combines several simple products into one sellable unit. Items within the bundle can be categorized into logical
   * categories (groups) like`tops`, `bottoms`, and `accessories`. Each group can have multiple items, and shoppers can
   * select items from each group to create a customized bundle. To create a bundle product, you need the following: -
   * [Bundle product](#operation/ProductsPost): Define the bundle product.
   * [Bundles](#operation/ProductsPost!path=bundles&t=request) is a required field that defines the groups and items
   * included in the bundle. - [Simple products](#operation/ProductsPost): Define the simple products that are included
   * in the bundle. Each simple product must be created separately using the create product API. In the field
   * ["links"](#operation/ProductsPost!path=links&t=request), the type `IN_BUNDLE` must be defined for simple products
   * that belong to bundle products with reference to it. <strong>Note:</strong> A simple product can be included only
   * once in each bundle. If the same item is specified in multiple groups, the API returns a `Duplicate SKU found in
   * bundle items` error. To update a bundle product, do one of the following: - Use [Update Product
   * API](#operation/ProductsPatch) to modify the groups and items in the bundle. - Use [Delete Product
   * API](#operation/ProductsDelete) to remove items from the bundle.
   *
   * @param data - Array<FeedProduct> payload
   * @returns {Promise<ProcessFeedResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  createProducts(data: Array<FeedProduct>): Promise<ProcessFeedResponse>;
  /**
   * Delete products. Delete products with specified "sku" and "scope".
   *
   * @param data - Array<FeedProductDelete> payload
   * @returns {Promise<ProcessFeedResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  deleteProducts(data: Array<FeedProductDelete>): Promise<ProcessFeedResponse>;
  /**
   * Update products. Update products with specified "sku" and "scope" to replace existing field data with the data
   * supplied in the request. When the update is processed, the merge strategy is used to apply changes to `scalar` and
   * `object` type fields. The replace strategy is used to apply changes for fields in an `array`.
   *
   * @param data - Array<FeedProductUpdate> payload
   * @returns {Promise<ProcessFeedResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  updateProducts(data: Array<FeedProductUpdate>): Promise<ProcessFeedResponse>;
}

/**
 * Creates a client instance for interacting with the Adobe Commerce Optimizer API.
 *
 * @example
 *   ```typescript
 *   // Define your configuration
 *   const config = {
 *     credentials: {
 *       clientId: process.env.IMS_CLIENT_ID!,
 *       clientSecret: process.env.IMS_CLIENT_SECRET!,
 *     },
 *     tenantId: process.env.TENANT_ID!,
 *     region: process.env.REGION as Region,
 *     environment: process.env.ENVIRONMENT as Environment,
 *   };
 *
 *   // Initialize the client instance
 *   const client = createClient(config);
 *
 *   // Use the client to interact with the API
 *   const response = await client.createProducts([product]);
 *   ```;
 *
 * @param clientConfig {ClientConfig} - SDK client configuration and authentication credentials
 * @returns {Client} A client instance with methods for interacting with the API
 */
export function createClient(clientConfig: ClientConfig): Client {
  const { credentials, tenantId, region, environment } = clientConfig;

  // Read .env overrides if present
  config();
  const auth = createAuthService(credentials, process.env.IMS_BASE_URL_OVERRIDE ?? undefined);
  const http = createHttpClient(auth, tenantId, region, environment, process.env.BASE_URL_OVERRIDE ?? undefined);

  return {
    async createProductMetadata(data: Array<FeedMetadata>): Promise<ProcessFeedResponse> {
      return await http.request<ProcessFeedResponse>(`/v1/catalog/products/metadata`, {
        method: 'POST',
        body: JSON.stringify(data),
      });
    },

    async deleteProductMetadata(data: Array<FeedMetadataDelete>): Promise<ProcessFeedResponse> {
      return await http.request<ProcessFeedResponse>(`/v1/catalog/products/metadata/delete`, {
        method: 'POST',
        body: JSON.stringify(data),
      });
    },

    async updateProductMetadata(data: Array<FeedMetadataUpdate>): Promise<ProcessFeedResponse> {
      return await http.request<ProcessFeedResponse>(`/v1/catalog/products/metadata`, {
        method: 'PATCH',
        body: JSON.stringify(data),
      });
    },

    async createPriceBooks(data: Array<FeedPricebook>): Promise<ProcessFeedResponse> {
      return await http.request<ProcessFeedResponse>(`/v1/catalog/price-books`, {
        method: 'POST',
        body: JSON.stringify(data),
      });
    },

    async deletePriceBooks(data: Array<FeedPricebook>): Promise<ProcessFeedResponse> {
      return await http.request<ProcessFeedResponse>(`/v1/catalog/price-books/delete`, {
        method: 'POST',
        body: JSON.stringify(data),
      });
    },

    async updatePriceBooks(data: Array<FeedPricebook>): Promise<ProcessFeedResponse> {
      return await http.request<ProcessFeedResponse>(`/v1/catalog/price-books`, {
        method: 'PATCH',
        body: JSON.stringify(data),
      });
    },

    async createPrices(data: Array<FeedPrices>): Promise<ProcessFeedResponse> {
      return await http.request<ProcessFeedResponse>(`/v1/catalog/products/prices`, {
        method: 'POST',
        body: JSON.stringify(data),
      });
    },

    async deletePrices(data: Array<FeedPricesDelete>): Promise<ProcessFeedResponse> {
      return await http.request<ProcessFeedResponse>(`/v1/catalog/products/prices/delete`, {
        method: 'POST',
        body: JSON.stringify(data),
      });
    },

    async updatePrices(data: Array<FeedPricesUpdate>): Promise<ProcessFeedResponse> {
      return await http.request<ProcessFeedResponse>(`/v1/catalog/products/prices`, {
        method: 'PATCH',
        body: JSON.stringify(data),
      });
    },

    async createProducts(data: Array<FeedProduct>): Promise<ProcessFeedResponse> {
      return await http.request<ProcessFeedResponse>(`/v1/catalog/products`, {
        method: 'POST',
        body: JSON.stringify(data),
      });
    },

    async deleteProducts(data: Array<FeedProductDelete>): Promise<ProcessFeedResponse> {
      return await http.request<ProcessFeedResponse>(`/v1/catalog/products/delete`, {
        method: 'POST',
        body: JSON.stringify(data),
      });
    },

    async updateProducts(data: Array<FeedProductUpdate>): Promise<ProcessFeedResponse> {
      return await http.request<ProcessFeedResponse>(`/v1/catalog/products`, {
        method: 'PATCH',
        body: JSON.stringify(data),
      });
    },
  };
}

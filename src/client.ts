/**
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2025 Adobe All Rights Reserved.
 *
 * NOTICE: All information contained herein is, and remains the property of Adobe and its suppliers, if any. The
 * intellectual and technical concepts contained herein are proprietary to Adobe and its suppliers and are protected by
 * all applicable intellectual property laws, including trade secret and copyright laws. Dissemination of this
 * information or reproduction of this material is strictly forbidden unless prior written permission is obtained from
 * Adobe.
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech) using custom templates.
 * Generator configuration can be found in the /generator directory.
 *
 * Do not edit this file manually!
 */

import { config } from 'dotenv';
import { createAuthService } from './auth';
import { createHttpClient, DEFAULT_TIMEOUT_MS, HttpClientConfig } from './http-client';
import { consoleLogger } from './logger';
import {
  ClientConfig,
  ApiResponse,
  FeedMetadata,
  FeedMetadataDelete,
  FeedMetadataUpdate,
  FeedPricebook,
  FeedPrices,
  FeedPricesDelete,
  FeedPricesUpdate,
  FeedProduct,
  FeedProductDelete,
  FeedProductUpdate,
} from './types';

export interface Client {
  /**
   * Create product attribute metadata To ensure product data is indexed for discovery, create or replace existing
   * product attribute metadata resources before creating products. For each Commerce project, you must define metadata
   * for the following attributes for each scope (`locale`): - `sku` - `name` - `description` - `shortDescription` -
   * `price` Also, you can define metadata for custom attributes. When creating product attribute metadata: - Each
   * product attribute requires a unique `code` and `scope`. - Use the `dataType` field to define the data type for the
   * product attribute. - Use the `visibleIn` field to define where the product attribute is displayed on the
   * storefront. - Use the `filterable`, `sortable`, and `searchable` fields to define how the product attribute is used
   * for filtering, sorting, and searching. - Use the `searchWeight` field to define the search weight for the product
   * attribute. - Use the `searchTypes` field to define the search type for the product attribute. To update existing
   * product attribute metadata, use the update operation.
   *
   * @param data - FeedMetadata[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  createProductMetadata(data: FeedMetadata[]): Promise<ApiResponse>;
  /**
   * Delete product attributes metadata Remove product attribute metadata resources from the catalog data.
   *
   * @param data - FeedMetadataDelete[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  deleteProductMetadata(data: FeedMetadataDelete[]): Promise<ApiResponse>;
  /**
   * Update product attribute metadata Update existing product attribute metadata with new values. When the update is
   * processed, the merge strategy is used to apply changes to `scalar` and `object` type fields. The replace strategy
   * is used to apply changes for fields in an `array`.
   *
   * @param data - FeedMetadataUpdate[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  updateProductMetadata(data: FeedMetadataUpdate[]): Promise<ApiResponse>;
  /**
   * Create price books Create or replace existing price books. Use the [update price books
   * operation](#operation/updatePriceBooks) to modify values for existing price books.
   *
   * @param data - FeedPricebook[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  createPriceBooks(data: FeedPricebook[]): Promise<ApiResponse>;
  /**
   * Delete price books Delete existing price books When you delete a price book, all associated prices assigned to the
   * `priceBookId` are also deleted. If a product does not have any other price books assigned, the prices default to
   * the pricing schedule defined in the default, `main` price book. Note that you cannot delete the default price book
   * with id `main`.
   *
   * @param data - FeedPricebook[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  deletePriceBooks(data: FeedPricebook[]): Promise<ApiResponse>;
  /**
   * Update price books Update existing price books to change the name or the currency used for pricing. When the update
   * is processed, the merge strategy is used to apply changes to `scalar` and `object` type fields. The replace
   * strategy is used to apply changes for fields in an `array`. To update the currency for the default price book, use
   * the price book id `main`.
   *
   * @param data - FeedPricebook[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  updatePriceBooks(data: FeedPricebook[]): Promise<ApiResponse>;
  /**
   * Create prices Create or replace existing product prices. A price must be associated with at least the default price
   * book with id `main`. <h3>Configurable Products</h3> Because configurable product price is calculated based on the
   * price of the selected product variant, you don't need to send price data for configurable product skus. Sending
   * price data for these skus can cause incorrect price calculations.
   *
   * @param data - FeedPrices[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  createPrices(data: FeedPrices[]): Promise<ApiResponse>;
  /**
   * Delete prices Delete existing product prices
   *
   * @param data - FeedPricesDelete[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  deletePrices(data: FeedPricesDelete[]): Promise<ApiResponse>;
  /**
   * Update prices Change existing product prices When the update is processed, the merge strategy is used to apply
   * changes to `scalar` and `object` type fields. The replace strategy is used to apply changes for fields in an
   * `array`.
   *
   * @param data - FeedPricesUpdate[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  updatePrices(data: FeedPricesUpdate[]): Promise<ApiResponse>;
  /**
   * Create or replace products You can create different types of products, such as simple products and configurable
   * products. When creating products: - Each product requires a unique SKU identifier. - Products must have a defined
   * scope, for example `locale`. - Add values for the required `name`, `slug`, and `status` fields. - Define optional
   * fields such as descriptions, images, and custom attributes as needed. - Use the `links` field to define
   * relationships between products, such as linking a product variant to its parent configurable product. - You can
   * create multiple products in a single request, and also create product variants for configurable products in the
   * same request. <h3 id="simpleProducts">Simple Products</h3> Create products or replace existing products with a
   * specified `sku` and `scope`. If a product with the same data exists with the same SKU and scope, the product update
   * request is ignored. Use the [update operation](#operation/updateProducts) to modify values for an existing
   * product.<h3 id="configurableProducts">Configurable Products</h3> A configurable product is a product that offers
   * multiple options, such as color and size. Each unique combination of these options, like 'color green' and 'size
   * large,' defines a product variant. This variant is an independent product with its own SKU, price, and inventory.
   * The configurable product acts as a container for these product variants. To create a configurable product, you need
   * the following: - [Product attributes](#operation/ProductMetadataPut): Define the product attributes used to define
   * a configurable product, such as "color", "size", etc. - Configurable product: Define the configurable product.
   * [Configurations](#operation/createProducts!path=configurations&t=request) is a required field. It defines the
   * choices that a shopper can select. - [Product variant](#operation/createProducts): Define a product variant for a
   * configurable product. The variant definition must have [Attributes](createProducts!path=attributes&t=request) with
   * [variantReferenceId](#operation/createProducts!path=attributes/variantReferenceId&t=request) and
   * [links](#operation/createProducts!path=links&t=request) of type `VARIANT_OF`. Each product variant links back to
   * the configurable product through its `variantReferenceId`, which corresponds to specific
   * `configurations[].values[].variantReferenceId` in the configurable product. To unassign a product variant from a
   * configurable product, do one of the following: - Use the [Delete products API](#operation/deleteProducts) to delete
   * the product variant. - Use the [Update products API](#operation/updateProducts)to set the
   * ["variantReferenceId"](#operation/createProducts!path=attributes/variantReferenceId&t=request) to `null` and
   * unassign the product variant from the configurable product by removing the
   * ["links"](#operation/createProducts!path=links&t=request) association. <h3>Bundle Products</h3> A bundle product
   * combines several simple products into one sellable unit. Items within the bundle can be categorized into logical
   * categories (groups) like`tops`, `bottoms`, and `accessories`. Each group can have multiple items, and shoppers can
   * select items from each group to create a customized bundle. To create a bundle product, you need the following: -
   * Bundle product: Use the Create products API to define the bundle product.
   * [Bundles](#operation/createProducts!path=bundles&t=request) is a required field that defines the groups and items
   * included in the bundle. - [Simple products](#simpleProducts): Define the simple products that are included in the
   * bundle. Each simple product must be created separately using the create product API. In the field ["links"](#), the
   * type `IN_BUNDLE` must be defined for simple products that belong to bundle products with reference to it.
   * <strong>Note:</strong> A simple product can be included only once in each bundle. If the same item is specified in
   * multiple groups, the API returns a `Duplicate SKU found in bundle items` error. To update a bundle product, do one
   * of the following: - Use [Update products API](#operation/updateProducts) to modify the groups and items in the
   * bundle. - Use [Delete products API](#operation/deleteProducts) to remove items from the bundle.
   *
   * @param data - FeedProduct[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  createProducts(data: FeedProduct[]): Promise<ApiResponse>;
  /**
   * Delete products Delete products with specified "sku" and "scope".
   *
   * @param data - FeedProductDelete[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  deleteProducts(data: FeedProductDelete[]): Promise<ApiResponse>;
  /**
   * Update products Update products with specified "sku" and "scope" to replace existing field data with the data
   * supplied in the request. When the update is processed, the merge strategy is used to apply changes to `scalar` and
   * `object` type fields. The replace strategy is used to apply changes for fields in an `array`.
   *
   * @param data - FeedProductUpdate[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  updateProducts(data: FeedProductUpdate[]): Promise<ApiResponse>;
}

/**
 * Creates a client instance for interacting with the Adobe Commerce Optimizer API.
 *
 * @example
 *   ```typescript
 *   // Define your configuration
 *   const config = {
 *     credentials: {
 *       clientId: process.env.IMS_CLIENT_ID!,
 *       clientSecret: process.env.IMS_CLIENT_SECRET!,
 *     },
 *     tenantId: process.env.TENANT_ID!,
 *     region: process.env.REGION as Region,
 *     environment: process.env.ENVIRONMENT as Environment,
 *   };
 *
 *   // Initialize the client instance
 *   const client = createClient(config);
 *
 *   // Use the client to interact with the API
 *   const response = await client.createProducts([product]);
 *   ```;
 *
 * @param clientConfig {ClientConfig} - SDK client configuration and authentication credentials
 * @returns {Client} A client instance with methods for interacting with the API
 */
export function createClient(clientConfig: ClientConfig): Client {
  const {
    credentials,
    tenantId,
    region,
    environment,
    timeoutMs = DEFAULT_TIMEOUT_MS,
    logger = consoleLogger(),
  } = clientConfig;

  // Read .env overrides if present
  config();
  const auth = createAuthService(credentials, process.env.IMS_BASE_URL_OVERRIDE ?? undefined);
  const httpConfig: HttpClientConfig = {
    auth,
    tenantId,
    region,
    environment,
    timeoutMs,
    logger,
  };
  const http = createHttpClient(httpConfig);

  return {
    async createProductMetadata(data: FeedMetadata[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/products/metadata`, {
        method: 'POST',
        body: JSON.stringify(data),
      });
    },

    async deleteProductMetadata(data: FeedMetadataDelete[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/products/metadata/delete`, {
        method: 'POST',
        body: JSON.stringify(data),
      });
    },

    async updateProductMetadata(data: FeedMetadataUpdate[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/products/metadata`, {
        method: 'PATCH',
        body: JSON.stringify(data),
      });
    },

    async createPriceBooks(data: FeedPricebook[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/price-books`, {
        method: 'POST',
        body: JSON.stringify(data),
      });
    },

    async deletePriceBooks(data: FeedPricebook[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/price-books/delete`, {
        method: 'POST',
        body: JSON.stringify(data),
      });
    },

    async updatePriceBooks(data: FeedPricebook[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/price-books`, {
        method: 'PATCH',
        body: JSON.stringify(data),
      });
    },

    async createPrices(data: FeedPrices[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/products/prices`, {
        method: 'POST',
        body: JSON.stringify(data),
      });
    },

    async deletePrices(data: FeedPricesDelete[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/products/prices/delete`, {
        method: 'POST',
        body: JSON.stringify(data),
      });
    },

    async updatePrices(data: FeedPricesUpdate[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/products/prices`, {
        method: 'PATCH',
        body: JSON.stringify(data),
      });
    },

    async createProducts(data: FeedProduct[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/products`, {
        method: 'POST',
        body: JSON.stringify(data),
      });
    },

    async deleteProducts(data: FeedProductDelete[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/products/delete`, {
        method: 'POST',
        body: JSON.stringify(data),
      });
    },

    async updateProducts(data: FeedProductUpdate[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/products`, {
        method: 'PATCH',
        body: JSON.stringify(data),
      });
    },
  };
}

/**
 * Copyright 2025 Adobe. All Rights Reserved.
 *
 * This file is licensed to you under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, either express or implied. See the License for
 * the specific language governing permissions and limitations under the License.
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech) using custom templates.
 * Generator configuration can be found in the /generator directory.
 *
 * Do not edit this file manually!
 */

import { config } from 'dotenv';
import { createAuthService } from './auth';
import { createHttpClient, DEFAULT_TIMEOUT_MS, HttpClientConfig } from './http-client';
import { consoleLogger } from './logger';
import {
  ClientConfig,
  ApiResponse,
  FeedMetadata,
  FeedMetadataDelete,
  FeedMetadataUpdate,
  FeedPriceBookDelete,
  FeedPricebook,
  FeedPrices,
  FeedPricesDelete,
  FeedPricesUpdate,
  FeedProduct,
  FeedProductDelete,
  FeedProductUpdate,
} from './types';

export interface Client {
  /**
   * Create product attribute metadata To ensure product data is indexed for discovery, create or replace existing
   * product attribute metadata resources before creating products. For each Commerce project, you must define metadata
   * for the following attributes for each catalog source (`locale`): - `sku` - `name` - `description` -
   * `shortDescription` - `price` Also, you can define metadata for custom attributes. When creating product attribute
   * metadata: - Each product attribute requires a unique `code` and `source`. - Use the `dataType` field to define the
   * data type for the product attribute. - Use the `visibleIn` field to define where the product attribute is displayed
   * on the storefront. - Use the `filterable`, `sortable`, and `searchable` fields to define how the product attribute
   * is used for filtering, sorting, and searching. - Use the `searchWeight` field to define the search weight for the
   * product attribute. - Use the `searchTypes` field to define the search type for the product attribute. To update
   * existing product attribute metadata, use the update operation.
   *
   * @param data - FeedMetadata[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  createProductMetadata(data: FeedMetadata[]): Promise<ApiResponse>;
  /**
   * Delete product attributes metadata Remove product attribute metadata resources from the catalog data.
   *
   * @param data - FeedMetadataDelete[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  deleteProductMetadata(data: FeedMetadataDelete[]): Promise<ApiResponse>;
  /**
   * Update product attribute metadata Update existing product attribute metadata with new values. When the update is
   * processed, the merge strategy is used to apply changes to `scalar` and `object` type fields. The replace strategy
   * is used to apply changes for fields in an `array`.
   *
   * @param data - FeedMetadataUpdate[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  updateProductMetadata(data: FeedMetadataUpdate[]): Promise<ApiResponse>;
  /**
   * Create price books Create or replace existing price books. Use the [update price books
   * operation](#operation/updatePriceBooks) to modify values for existing price books. <strong>Note:</strong> After you
   * assign a `parentId` to a price book, you cannot change the parentId value using the update operation. If you want
   * to define a different parent-child relationship, delete the child price book and create a new one with the desired
   * parent-child relationship.
   *
   * @param data - FeedPricebook[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  createPriceBooks(data: FeedPricebook[]): Promise<ApiResponse>;
  /**
   * Delete price books When you delete a price book, all its child price books and all prices assigned to the
   * `priceBookId` and its children are also deleted. If a price book is deleted by mistake, you have up to one week to
   * restore the deleted price books and their associated prices. Restoring is done by recreating the top-level parent
   * price book that was deleted, using the same payload submitted in the original create price book request. The state
   * of the price books and prices are restored to the status and price values assigned when the price book was
   * deleted.
   *
   * @param data - FeedPriceBookDelete[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  deletePriceBooks(data: FeedPriceBookDelete[]): Promise<ApiResponse>;
  /**
   * Update price books Change the name of a base or child price book, or change the currency assigned to the base price
   * book. When you submit the update request for a child price book, include the correct `parentId`. If the request
   * includes a different `parentId`, the value is ignored.
   *
   * @param data - FeedPricebook[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  updatePriceBooks(data: FeedPricebook[]): Promise<ApiResponse>;
  /**
   * Create prices Create or replace existing product prices. <h3>Configurable Products</h3> Because configurable
   * product price is calculated based on the price of the selected product variant, you don't need to send price data
   * for configurable product skus. Sending price data for these skus can cause incorrect price calculations.
   *
   * @param data - FeedPrices[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  createPrices(data: FeedPrices[]): Promise<ApiResponse>;
  /**
   * Delete prices Delete existing product prices
   *
   * @param data - FeedPricesDelete[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  deletePrices(data: FeedPricesDelete[]): Promise<ApiResponse>;
  /**
   * Update prices Change existing product prices When the update is processed, the merge strategy is used to apply
   * changes to `scalar` and `object` type fields. The replace strategy is used to apply changes for fields in an
   * `array`.
   *
   * @param data - FeedPricesUpdate[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  updatePrices(data: FeedPricesUpdate[]): Promise<ApiResponse>;
  /**
   * Create or replace products You can create different types of products, such as simple products and configurable
   * products. When creating products: - Each product requires a unique SKU identifier. - Products must have a defined
   * catalog source, for example `locale`. - Add values for the required `name`, `slug`, and `status` fields. - Define
   * optional fields such as descriptions, images, and custom attributes as needed. - Use the `links` field to define
   * relationships between products, such as linking a product variant to its parent configurable product. - You can
   * create multiple products in a single request, and also create product variants for configurable products in the
   * same request. <h3 id="simpleProducts">Simple Products</h3> Create products or replace existing products with
   * specified `sku` and `source` values. Use the <strong>[update operation](#operation/updateProducts)</strong> to
   * modify values for an existing product. <h3>Configurable Products</h3> A configurable product is a parent product
   * that allows customers to select from multiple predefined attributes such as color, size, and material. Each unique
   * combination of these attribute values (for example, `color=green`, `size=large`) represents a product variant. Each
   * variant is treated as a distinct child product with its own SKU, price, and inventory. These variants are stored as
   * separate entities in the database and linked to the parent configurable product. The configurable product itself
   * acts as a container or abstraction layer, enabling a unified frontend experience while maintaining granular control
   * over each variant on the backend. To create a configurable product, you need the following: * <strong>Product
   * attributes</strong>—<a href="#operation/createProductMetadata">Create product attributes</a> (for example, "color",
   * "size") that will be used to differentiate product variants. These attributes must be registered in the system
   * before they can be referenced in product definitions. * <strong>Configurable product</strong>—Define the parent
   * product and include a [configurations](#operation/createProducts!path=configurations&t=request) array that
   * specifies the selectable options and maps each option to a set of possible values. Each value must include a
   * [variantReferenceId](#operation/createProducts!path=configurations/values/variantReferenceId&t=request), which
   * links to a specific variant. * <strong>Product variants</strong>—Define a product variant for each valid
   * combination of attribute values. Each variant must: * Include relevant attribute values in an
   * [attributes](#operation/createProducts!path=attributes&t=request) array. * Reference the parent configurable
   * product using variantReferenceId. * Include a [links](#operation/createProducts!path=links&t=request) array with a
   * link of type `VARIANT_OF` pointing to the configurable product. For example: <pre> { "sku": "pants-red-32",
   * "attributes": [ { "code": "color", "values": ["Red"], "variantReferenceId": "pants-color-red" } ], "links": [ {
   * "type": "VARIANT_OF", "sku": "pants" } ] } </pre> Each product variant links back to the configurable product
   * through its `variantReferenceId`, which corresponds to specific `configurations[].values[].variantReferenceId` in
   * the configurable product. To unassign a product variant from a configurable product, do one of the following: - Use
   * [Delete Product API](#operation/deleteProducts) to delete the product variant. - Use [Update Product
   * API](#operation/updateProducts) to set the
   * ["variantReferenceId"](#operation/createProducts!path=attributes/variantReferenceId&t=request) to `null` and
   * unassign the product variant from the configurable product by removing the
   * ["links"](#operation/createProducts!path=links&t=request) association. <h3>Bundle Products</h3> A bundle product
   * combines several simple products into one sellable unit. Items within the bundle can be categorized into logical
   * groups like `tops`, `bottoms`, and `accessories`. Each group can have multiple items, and shoppers can select items
   * from each group to create a customized bundle. To create a bundle product, you need the following: * <strong>Bundle
   * product</strong>—[Define the parent product](#operation/createProducts) and include a
   * [bundles](#operation/createProducts!path=bundles) array that specifies the groups and items included in the bundle.
   * Each group must define: * `group` - Name of the group (for example, "tops", "bottoms") * `required` - Whether a
   * selection from this group is mandatory * `multiSelect` - Whether multiple items can be selected * `items` - List of
   * products that can be selected from this group * <strong>Simple products</strong>—Define each simple product to
   * include in the bundle. Each product must: * Include a [links](#operation/createProducts!path=links) array with a
   * link of type `IN_BUNDLE` pointing to the bundle product * Be created separately using the [create product
   * API](#operation/createProducts) <strong>Note:</strong> A simple product can be included only once in each bundle.
   * If the same item is specified in multiple groups, the API returns a `Duplicate SKU found in bundle items` error. To
   * update a bundle product, do one of the following: * Use the [Update products API](#operation/updateProducts) to
   * modify the groups and items in the bundle * Use the [Delete products API](#operation/deleteProducts) to remove
   * items from the bundle
   *
   * @param data - FeedProduct[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  createProducts(data: FeedProduct[]): Promise<ApiResponse>;
  /**
   * Delete products Delete products with specified `sku`` and `source`` values
   *
   * @param data - FeedProductDelete[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  deleteProducts(data: FeedProductDelete[]): Promise<ApiResponse>;
  /**
   * Update products Update products with specified `sku` and `source` values to replace existing field data with the
   * data supplied in the request. When the update is processed, the merge strategy is used to apply changes to `scalar`
   * and `object` type fields. The replace strategy is used to apply changes for fields in an `array`.
   *
   * @param data - FeedProductUpdate[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  updateProducts(data: FeedProductUpdate[]): Promise<ApiResponse>;
}

/**
 * Creates a client instance for interacting with the Adobe Commerce Optimizer API.
 *
 * @example
 *   ```typescript
 *   // Define your configuration
 *   const config = {
 *     credentials: {
 *       clientId: process.env.IMS_CLIENT_ID!,
 *       clientSecret: process.env.IMS_CLIENT_SECRET!,
 *     },
 *     tenantId: process.env.TENANT_ID!,
 *     region: process.env.REGION as Region,
 *     environment: process.env.ENVIRONMENT as Environment,
 *   };
 *
 *   // Initialize the client instance
 *   const client = createClient(config);
 *
 *   // Use the client to interact with the API
 *   const response = await client.createProducts([product]);
 *   ```;
 *
 * @param clientConfig {ClientConfig} - SDK client configuration and authentication credentials
 * @returns {Client} A client instance with methods for interacting with the API
 */
export function createClient(clientConfig: ClientConfig): Client {
  const {
    credentials,
    tenantId,
    region,
    environment,
    timeoutMs = DEFAULT_TIMEOUT_MS,
    logger = consoleLogger(),
  } = clientConfig;

  // Read .env overrides if present
  config();
  const auth = createAuthService(credentials, process.env.IMS_BASE_URL_OVERRIDE ?? undefined);
  const httpConfig: HttpClientConfig = {
    auth,
    tenantId,
    region,
    environment,
    timeoutMs,
    logger,
    baseUrlOverride: process.env.BASE_URL_OVERRIDE ?? undefined,
  };
  const http = createHttpClient(httpConfig);

  return {
    async createProductMetadata(data: FeedMetadata[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/products/metadata`, {
        method: 'POST',
        body: JSON.stringify(data),
      });
    },

    async deleteProductMetadata(data: FeedMetadataDelete[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/products/metadata/delete`, {
        method: 'POST',
        body: JSON.stringify(data),
      });
    },

    async updateProductMetadata(data: FeedMetadataUpdate[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/products/metadata`, {
        method: 'PATCH',
        body: JSON.stringify(data),
      });
    },

    async createPriceBooks(data: FeedPricebook[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/price-books`, {
        method: 'POST',
        body: JSON.stringify(data),
      });
    },

    async deletePriceBooks(data: FeedPriceBookDelete[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/price-books/delete`, {
        method: 'POST',
        body: JSON.stringify(data),
      });
    },

    async updatePriceBooks(data: FeedPricebook[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/price-books`, {
        method: 'PATCH',
        body: JSON.stringify(data),
      });
    },

    async createPrices(data: FeedPrices[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/products/prices`, {
        method: 'POST',
        body: JSON.stringify(data),
      });
    },

    async deletePrices(data: FeedPricesDelete[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/products/prices/delete`, {
        method: 'POST',
        body: JSON.stringify(data),
      });
    },

    async updatePrices(data: FeedPricesUpdate[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/products/prices`, {
        method: 'PATCH',
        body: JSON.stringify(data),
      });
    },

    async createProducts(data: FeedProduct[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/products`, {
        method: 'POST',
        body: JSON.stringify(data),
      });
    },

    async deleteProducts(data: FeedProductDelete[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/products/delete`, {
        method: 'POST',
        body: JSON.stringify(data),
      });
    },

    async updateProducts(data: FeedProductUpdate[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/products`, {
        method: 'PATCH',
        body: JSON.stringify(data),
      });
    },
  };
}

/**
 * Copyright 2025 Adobe. All Rights Reserved.
 *
 * This file is licensed to you under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, either express or implied. See the License for
 * the specific language governing permissions and limitations under the License.
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech) using custom templates.
 * Generator configuration can be found in the /generator directory.
 *
 * Do not edit this file manually!
 */

import { config } from 'dotenv';
import { createAuthService } from './auth';
import { createHttpClient, DEFAULT_TIMEOUT_MS, HttpClientConfig } from './http-client';
import { consoleLogger } from './logger';
import {
  ClientConfig,
  ApiResponse,
  FeedCategory,
  FeedCategoryDelete,
  FeedCategoryUpdate,
  FeedMetadata,
  FeedMetadataDelete,
  FeedMetadataUpdate,
  FeedPriceBookDelete,
  FeedPricebook,
  FeedPrices,
  FeedPricesDelete,
  FeedPricesUpdate,
  FeedProduct,
  FeedProductDelete,
  FeedProductUpdate,
} from './types';

export interface Client {
  /**
   * Create categories Create new categories with hierarchical structure and slug-based paths. Categories organize
   * products into logical groups and support nested hierarchies. When creating categories: - Each category requires a
   * unique `slug` and `source`. - Use the `slug` field in a hierarchical format like men/clothing/pants' to create
   * parent-child relationships - The category `slug` string can contain only lowercase letters, numbers, and hyphens. -
   * Use the `name` field to define the display name for the category. - Use the optional `families` field to associate
   * categories with product families for enhanced organization. To update existing categories, use the update
   * operation.
   *
   * @param data - FeedCategory[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  createCategories(data: FeedCategory[]): Promise<ApiResponse>;
  /**
   * Delete categories Delete categories and all their associated children <h3>Cascading Deletion</h3> When you delete a
   * category: * **Child categories**: All child categories in the hierarchy are deleted automatically * **Hierarchy
   * Impact**: The entire branch below the deleted category is removed <h3>Recovery Options</h3> If a category is
   * deleted by mistake: * **Time Window**: You have up to one week to restore deleted categories * **Restoration
   * Method**: Recreate the top-level deleted category using the [update operation](#operation/createCategories) *
   * **State Recovery**: Categories are restored to their exact state from the time of deletion, including all metadata,
   * family associations, and hierarchy relationships * **Hierarchy Reconstruction**: The entire hierarchy is rebuilt
   * from the restoration payload
   *
   * @param data - FeedCategoryDelete[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  deleteCategories(data: FeedCategoryDelete[]): Promise<ApiResponse>;
  /**
   * Update categories Update existing product categories with new values. When the update is processed, the merge
   * strategy is used to apply changes to `scalar` and `object` type fields. The replace strategy is used to apply
   * changes for fields in an `array`.
   *
   * @param data - FeedCategoryUpdate[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  updateCategories(data: FeedCategoryUpdate[]): Promise<ApiResponse>;
  /**
   * Create product attribute metadata To ensure product data is indexed for discovery, create or replace existing
   * product attribute metadata resources before creating products. For each Commerce project, you must define metadata
   * for the following attributes for each catalog source (`locale`): - `sku` - `name` - `description` -
   * `shortDescription` - `price` Also, you can define metadata for custom attributes. When creating product attribute
   * metadata: - Each product attribute requires a unique `code` and `source`. - Use the `dataType` field to define the
   * data type for the product attribute. - Use the `visibleIn` field to define where the product attribute is displayed
   * on the storefront. - Use the `filterable`, `sortable`, and `searchable` fields to define how the product attribute
   * is used for filtering, sorting, and searching. - Use the `searchWeight` field to define the search weight for the
   * product attribute. - Use the `searchTypes` field to define the search type for the product attribute. To update
   * existing product attribute metadata, use the update operation.
   *
   * @param data - FeedMetadata[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  createProductMetadata(data: FeedMetadata[]): Promise<ApiResponse>;
  /**
   * Delete product attributes metadata Remove product attribute metadata resources from the catalog data.
   *
   * @param data - FeedMetadataDelete[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  deleteProductMetadata(data: FeedMetadataDelete[]): Promise<ApiResponse>;
  /**
   * Update product attribute metadata Update existing product attribute metadata with new values. When the update is
   * processed, the merge strategy is used to apply changes to `scalar` and `object` type fields. The replace strategy
   * is used to apply changes for fields in an `array`.
   *
   * @param data - FeedMetadataUpdate[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  updateProductMetadata(data: FeedMetadataUpdate[]): Promise<ApiResponse>;
  /**
   * Create price books Create or replace existing price books with support for hierarchical pricing
   * structures.<h3>Creating Base Price Books</h3> Base price books are the foundation of your pricing hierarchy: *
   * **Required Fields**: `priceBookId`, `name`, `currency` * **Currency Definition**: Sets the currency for the entire
   * branch of child price books * **No Parent**: Base price books cannot reference a parent price book * **Unique ID**:
   * Must have a unique `priceBookId` across all price books <h3>Creating Child Price Books</h3> Child price books
   * inherit from their parent and can extend the hierarchy: * **Required Fields**: `priceBookId`, `name`, `parentId` *
   * **Parent Reference**: Must reference an existing parent price book * **Currency Inheritance**: Automatically
   * inherits currency from parent * **Hierarchy Depth**: Can create up to 3 levels of nesting <h3>Hierarchy
   * Management</h3> * **Parent Assignment**: Once a `parentId` is assigned, it cannot be changed via update operations
   *
   * - **Restructuring**: To change parent-child relationships, delete and recreate the child price book * **Validation**:
   *   The system validates parent references and hierarchy depth limits Use the [update price books
   *   operation](#operation/updatePriceBooks) to modify existing price book names or base price book currencies.
   *
   * @param data - FeedPricebook[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  createPriceBooks(data: FeedPricebook[]): Promise<ApiResponse>;
  /**
   * Delete price books Delete price books and their associated pricing data with cascading effects on the
   * hierarchy.<h3>Cascading Deletion</h3> When you delete a price book: * **Child Price Books**: All child price books
   * in the hierarchy are automatically deleted * **Associated Prices**: All prices assigned to the deleted price book
   * and its children are removed * **Hierarchy Impact**: The entire branch below the deleted price book is
   * removed<h3>Deletion Scenarios</h3> * **Base Price Book**: Deletes entire pricing hierarchy and all associated
   * prices * **Child Price Book**: Deletes the specific price book and its children, but preserves sibling price books
   *
   * - **Leaf Price Book**: Deletes only the specified price book and its associated prices <h3>Recovery Options</h3> If a
   *   price book is deleted by mistake: * **Time Window**: You have up to one week to restore deleted price books *
   *   **Restoration Method**: Recreate the top-level parent price book using the original create payload * **State
   *   Recovery**: Price books and prices are restored to their state when deleted * **Hierarchy Reconstruction**: The
   *   entire hierarchy is rebuilt from the restoration payload <h3>Best Practices</h3> * **Backup Strategy**: Keep
   *   copies of price book configurations for recovery * **Validation**: Verify hierarchy structure before deletion *
   *   **Impact Assessment**: Review associated prices before deleting price books
   *
   * @param data - FeedPriceBookDelete[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  deletePriceBooks(data: FeedPriceBookDelete[]): Promise<ApiResponse>;
  /**
   * Update price books Update existing price books with limitations on hierarchical changes. <h3>Updatable Fields</h3>
   *
   * - **Name**: Can be updated for both base and child price books * **Currency**: Can only be updated for base price
   *   books (affects entire hierarchy) * **Parent ID**: Cannot be updated - use delete and recreate to change
   *   hierarchy<h3>Update Restrictions</h3> * **Parent Assignment**: Cannot change `parentId` via update operations *
   *   **Hierarchy Changes**: To restructure the hierarchy, delete and recreate child price books * **Currency
   *   Inheritance**: Child price books automatically inherit currency changes from parent * **Validation**: System
   *   validates that `parentId` references exist and hierarchy depth is maintained <h3>Update Strategies</h3> * **Base
   *   Price Books**: Update name and currency as needed * **Child Price Books**: Include correct `parentId` in request
   *   (will be ignored if different) * **Hierarchy Restructuring**: Delete child price book and recreate with new
   *   parent reference
   *
   * @param data - FeedPricebook[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  updatePriceBooks(data: FeedPricebook[]): Promise<ApiResponse>;
  /**
   * Create prices Create or replace existing product prices with support for regular pricing, discounts, and tiered
   * pricing. <h3>Pricing structure</h3> Each price record can include: * **Regular Price** - The base price for the
   * product SKU * **Discounts** - Percentage or fixed amount discounts applied to the regular price * **Tiered
   * Pricing** - Quantity-based pricing for bulk purchases <h3>Discount configuration</h3> Discounts can be configured
   * in two ways: * **Fixed Amount Discounts** - Use `price` field to specify a fixed discount amount (e.g., 10.00 for
   * $10 off) * **Percentage Discounts** - Use `percentage` field to specify a discount percentage (e.g., 20 for 20%
   * off) Each discount requires a unique `code` identifier to distinguish between different discount types. <h3>Tiered
   * pricing</h3> Tiered pricing offers different prices based on purchase quantity: * **Tier Fixed Prices** - Use
   * `price` field with `qty` to specify quantity-based fixed prices * **Tier Percentage Discounts** - Use `percentage`
   * field with `qty` to specify quantity-based percentage discounts Tier quantities must be greater than 1. <h3>Pricing
   * for configurable products</h3> Because configurable product price is calculated based on the price of the selected
   * product variant, you don't need to send the price data for configurable product SKUs. Sending price data for these
   * SKUs can cause incorrect price calculations.
   *
   * @param data - FeedPrices[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  createPrices(data: FeedPrices[]): Promise<ApiResponse>;
  /**
   * Delete prices Delete existing product prices
   *
   * @param data - FeedPricesDelete[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  deletePrices(data: FeedPricesDelete[]): Promise<ApiResponse>;
  /**
   * Update prices Change existing product prices, discounts, and tiered pricing. When the update is processed, the
   * merge strategy is used to apply changes to `scalar` and `object` type fields. For `array` type fields, a new value
   * can be appended to the existing list. For an object list, you can update a specific object by matching on a key
   * field. The following fields are supported: * `discounts` - match on `code` * `tierPrices` - match on
   * `qty`<h3>Update strategies</h3> * **Regular Price** - Updated using merge strategy * **Discounts Array** - Updated
   * using the append or merge strategy * **Tiered Pricing Array** - Updated using the append or merge
   * strategy<h3>Discount and tier pricing updates</h3> When updating discounts or tiered pricing: * Include all desired
   * discounts/tiers in the array * The entire array replaces the existing configuration * To remove all
   * discounts/tiers, send an empty array * To add new discounts/tiers, include both existing and new items <h3>Best
   * practices</h3> * Always include the complete array of discounts/tiers when updating * Use descriptive discount
   * codes for easier management * Ensure tier quantities are in ascending order * Test updates in a development
   * environment first
   *
   * @param data - FeedPricesUpdate[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  updatePrices(data: FeedPricesUpdate[]): Promise<ApiResponse>;
  /**
   * Create or replace products You can create different types of products, such as simple products and configurable
   * products. When creating products: - Each product requires a unique SKU identifier. - Products must have a defined
   * catalog source, for example `locale`. - Add values for the required `name`, `slug`, and `status` fields. - Define
   * optional fields such as descriptions, images, and custom attributes as needed. - Use the `links` field to define
   * relationships between products, such as linking a product variant to its parent configurable product. - You can
   * create multiple products in a single request, and also create product variants for configurable products in the
   * same request. <h3 id="simpleProducts">Simple products</h3> Create products or replace existing products with
   * specified `sku` and `source` values. Use the <strong>[update operation](#operation/updateProducts)</strong> to
   * modify values for an existing product. <h3 id="configurableProducts">Configurable products</h3> A configurable
   * product is a parent product that allows customers to select from multiple predefined attributes such as color,
   * size, and material. Each unique combination of these attribute values (for example, `color=green`, `size=large`)
   * represents a product variant. Each variant is treated as a distinct child product with its own SKU, price, and
   * inventory. These variants are stored as separate entities in the database and linked to the parent configurable
   * product. The configurable product itself acts as a container or abstraction layer, enabling a unified frontend
   * experience while maintaining granular control over each variant on the backend. To create a configurable product,
   * you need the following: * <strong>Product attributes</strong>—<a href="#operation/createProductMetadata">Create
   * product attributes</a> (for example, "color", "size") that will be used to differentiate product variants. These
   * attributes must be registered in the system before they can be referenced in product definitions. *
   * <strong>Configurable product</strong>—Define the parent product and include a
   * [configurations](#operation/createProducts!path=configurations&t=request) array that specifies the selectable
   * options and maps each option to a set of possible values. Each value must include a
   * [variantReferenceId](#operation/createProducts!path=configurations/values/variantReferenceId&t=request), which
   * links to a specific variant. * <strong>Product variants</strong>—Define a product variant for each valid
   * combination of attribute values. Each variant must: * Include relevant attribute values in an
   * [attributes](#operation/createProducts!path=attributes&t=request) array. * Reference the parent configurable
   * product using variantReferenceId. * Include a [links](#operation/createProducts!path=links&t=request) array with a
   * link of type `VARIANT_OF` pointing to the configurable product. For example: <pre> { "sku": "pants-red-32",
   * "attributes": [ { "code": "color", "values": ["Red"], "variantReferenceId": "pants-color-red" } ], "links": [ {
   * "type": "VARIANT_OF", "sku": "pants" } ] } </pre> Each product variant links back to the configurable product
   * through its `variantReferenceId`, which corresponds to specific `configurations[].values[].variantReferenceId` in
   * the configurable product. To unassign a product variant from a configurable product, do one of the following: - Use
   * [Delete Product API](#operation/deleteProducts) to delete the product variant. - Use [Update Product
   * API](#operation/updateProducts) to set the
   * ["variantReferenceId"](#operation/createProducts!path=attributes/variantReferenceId&t=request) to `null` and
   * unassign the product variant from the configurable product by removing the
   * ["links"](#operation/createProducts!path=links&t=request) association. <h3>Bundle products</h3> A bundle product
   * combines several simple products into one sellable unit. Items within the bundle can be categorized into logical
   * groups like `tops`, `bottoms`, and `accessories`. Each group can have multiple items, and shoppers can select items
   * from each group to create a customized bundle. To create a bundle product, you need the following: * <strong>Bundle
   * product</strong>—[Define the parent product](#operation/createProducts) and include a
   * [bundles](#operation/createProducts!path=bundles) array that specifies the groups and items included in the bundle.
   * Each group must define: * `group` - Name of the group (for example, "tops", "bottoms") * `required` - Whether a
   * selection from this group is mandatory * `multiSelect` - Whether multiple items can be selected * `items` - List of
   * products that can be selected from this group * <strong>Simple products</strong>—Define each simple product to
   * include in the bundle. Each product must: * Include a [links](#operation/createProducts!path=links) array with a
   * link of type `IN_BUNDLE` pointing to the bundle product * Be created separately using the [create product
   * API](#operation/createProducts) <strong>Note:</strong> A simple product can be included only once in each bundle.
   * If the same item is specified in multiple groups, the API returns a `Duplicate SKU found in bundle items` error. To
   * update a bundle product, do one of the following: * Use the [Update products API](#operation/updateProducts) to
   * modify the groups and items in the bundle * Use the [Delete products API](#operation/deleteProducts) to remove
   * items from the bundle
   *
   * @param data - FeedProduct[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  createProducts(data: FeedProduct[]): Promise<ApiResponse>;
  /**
   * Delete products Delete products with specified `sku`` and `source`` values
   *
   * @param data - FeedProductDelete[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  deleteProducts(data: FeedProductDelete[]): Promise<ApiResponse>;
  /**
   * Update products Update products with specified `sku` and `source` values to replace existing field data with the
   * data supplied in the request. When the update is processed, the merge strategy is used to apply changes to `scalar`
   * and `object` type fields. For `array` type fields, a new value can be appended to the existing list. For an object
   * list, you can update a specific object by matching on a key field. The following fields are supported: *
   * `attributes` - match on `code` * `images` - match on `url` * `routes` - match on `path` * `links` - match on `type`
   * and `sku` * `bundles` match on `type` and `group` * `configurations` match on `type` and `attributeCode` *
   * `externalIds` match on `type` and `origin`
   *
   * @param data - FeedProductUpdate[] payload
   * @returns {Promise<ApiResponse>} Feed response indicating the number of accepted items
   * @throws {Error} If the API request fails
   */
  updateProducts(data: FeedProductUpdate[]): Promise<ApiResponse>;
}

/**
 * Creates a client instance for interacting with the Adobe Commerce Optimizer API.
 *
 * @example
 *   ```typescript
 *   // Define your configuration
 *   const config = {
 *     credentials: {
 *       clientId: process.env.IMS_CLIENT_ID!,
 *       clientSecret: process.env.IMS_CLIENT_SECRET!,
 *     },
 *     tenantId: process.env.TENANT_ID!,
 *     region: process.env.REGION as Region,
 *     environment: process.env.ENVIRONMENT as Environment,
 *   };
 *
 *   // Initialize the client instance
 *   const client = createClient(config);
 *
 *   // Use the client to interact with the API
 *   const response = await client.createProducts([product]);
 *   ```;
 *
 * @param clientConfig {ClientConfig} - SDK client configuration and authentication credentials
 * @returns {Client} A client instance with methods for interacting with the API
 */
export function createClient(clientConfig: ClientConfig): Client {
  const {
    credentials,
    tenantId,
    region,
    environment,
    timeoutMs = DEFAULT_TIMEOUT_MS,
    logger = consoleLogger(),
  } = clientConfig;

  // Read .env overrides if present
  config();
  const auth = createAuthService(credentials, process.env.IMS_BASE_URL_OVERRIDE ?? undefined);
  const httpConfig: HttpClientConfig = {
    auth,
    tenantId,
    region,
    environment,
    timeoutMs,
    logger,
    baseUrlOverride: process.env.BASE_URL_OVERRIDE ?? undefined,
  };
  const http = createHttpClient(httpConfig);

  return {
    async createCategories(data: FeedCategory[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/categories`, {
        method: 'POST',
        body: JSON.stringify(data),
      });
    },

    async deleteCategories(data: FeedCategoryDelete[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/categories/delete`, {
        method: 'POST',
        body: JSON.stringify(data),
      });
    },

    async updateCategories(data: FeedCategoryUpdate[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/categories`, {
        method: 'PATCH',
        body: JSON.stringify(data),
      });
    },

    async createProductMetadata(data: FeedMetadata[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/products/metadata`, {
        method: 'POST',
        body: JSON.stringify(data),
      });
    },

    async deleteProductMetadata(data: FeedMetadataDelete[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/products/metadata/delete`, {
        method: 'POST',
        body: JSON.stringify(data),
      });
    },

    async updateProductMetadata(data: FeedMetadataUpdate[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/products/metadata`, {
        method: 'PATCH',
        body: JSON.stringify(data),
      });
    },

    async createPriceBooks(data: FeedPricebook[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/price-books`, {
        method: 'POST',
        body: JSON.stringify(data),
      });
    },

    async deletePriceBooks(data: FeedPriceBookDelete[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/price-books/delete`, {
        method: 'POST',
        body: JSON.stringify(data),
      });
    },

    async updatePriceBooks(data: FeedPricebook[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/price-books`, {
        method: 'PATCH',
        body: JSON.stringify(data),
      });
    },

    async createPrices(data: FeedPrices[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/products/prices`, {
        method: 'POST',
        body: JSON.stringify(data),
      });
    },

    async deletePrices(data: FeedPricesDelete[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/products/prices/delete`, {
        method: 'POST',
        body: JSON.stringify(data),
      });
    },

    async updatePrices(data: FeedPricesUpdate[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/products/prices`, {
        method: 'PATCH',
        body: JSON.stringify(data),
      });
    },

    async createProducts(data: FeedProduct[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/products`, {
        method: 'POST',
        body: JSON.stringify(data),
      });
    },

    async deleteProducts(data: FeedProductDelete[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/products/delete`, {
        method: 'POST',
        body: JSON.stringify(data),
      });
    },

    async updateProducts(data: FeedProductUpdate[]): Promise<ApiResponse> {
      return await http.request(`/v1/catalog/products`, {
        method: 'PATCH',
        body: JSON.stringify(data),
      });
    },
  };
}

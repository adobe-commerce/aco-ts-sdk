/**
 * Catalog Data Ingestion API
 * The Catalog Data Ingestion API allows you to create and manage products and price books and directly integrate catalog data with the Commerce catalog service.   This API provides the following resource collections to create and update catalog data:   - **Metadata**—define and manage product attribute display on the storefront, define search characteristics, and so on  - **Products**—define and manage items to include in a commerce catalog. Each product can have multiple attributes like name, description, SKU, images, etc.  - **Price books**—define and manage unique scopes that can be used to manage product price discounts across customer tiers  - **Prices**—define and manage the prices associated with product SKUs and assign the pricing scope where the price is used 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { createHttpClient } from "./http-client";
import {
  AdobeCredentials,
  Region,
  Environment,
  DiscountsFinalPrice,
  DiscountsPercentage,
  FeedItemFailedValidationResult,
  FeedMetadata,
  FeedMetadataDelete,
  FeedMetadataUpdate,
  FeedPricebook,
  FeedPrices,
  FeedPricesDelete,
  FeedPricesDiscountsInner,
  FeedPricesUpdate,
  FeedProduct,
  FeedProductDelete,
  FeedProductUpdate,
  ItemFailedValidationResult,
  Model400ProcessFeedResponse,
  Model403Response,
  Model403Unauthorized,
  Model403UnauthorizedError,
  Model403UnauthorizedErrorDetails,
  Model403UnauthorizedInvalidJWT,
  ProcessFeedResponse,
  ProductAttribute,
  ProductImage,
  ProductLink,
  ProductMetaAttribute,
  ProductOption,
  ProductOptionValue,
  ProductRoutes,
  Scope,
} from "./types";
import { createAuthService } from "./auth";
import { config } from "dotenv";

export interface Client {
  createProductMetadata(data: Array<FeedMetadata>): Promise<ProcessFeedResponse>;
  deleteProductMetadata(data: Array<FeedMetadataDelete>): Promise<ProcessFeedResponse>;
  updateProductMetadata(data: Array<FeedMetadataUpdate>): Promise<ProcessFeedResponse>;
  createPriceBooks(data: Array<FeedPricebook>): Promise<ProcessFeedResponse>;
  deletePriceBooks(data: Array<FeedPricebook>): Promise<ProcessFeedResponse>;
  updatePricebooks(data: Array<FeedPricebook>): Promise<ProcessFeedResponse>;
  createPrices(data: Array<FeedPrices>): Promise<ProcessFeedResponse>;
  deletePrices(data: Array<FeedPricesDelete>): Promise<ProcessFeedResponse>;
  updatePrices(data: Array<FeedPricesUpdate>): Promise<ProcessFeedResponse>;
  createProducts(data: Array<FeedProduct>): Promise<ProcessFeedResponse>;
  deleteProducts(data: Array<FeedProductDelete>): Promise<ProcessFeedResponse>;
  updateProducts(data: Array<FeedProductUpdate>): Promise<ProcessFeedResponse>;
}

export function createClient(
  credentials: AdobeCredentials,
  tenantId: string,
  region: Region,
  environment: Environment
): Client {
  // Read .env overrides if present
  config();
  const auth = createAuthService(credentials, process.env.IMS_BASE_URL_OVERRIDE ?? undefined);
  const http = createHttpClient(auth, tenantId, region, environment, process.env.BASE_URL_OVERRIDE ?? undefined);

  return {
    /**
     * Create product attribute metadata.
     * Create or replace existing product attribute metadata resources.  To update existing product attribute metadata, use the update operation. 
     * @param data - Array<FeedMetadata> payload
     * @returns {Promise<ProcessFeedResponse>} feed response indicating the number of accepted items
     * @throws {Error} if the API request fails
     */
    async createProductMetadata(data: Array<FeedMetadata>): Promise<ProcessFeedResponse> {
      return await http.request<ProcessFeedResponse>(`/v1/catalog/products/metadata`, {
        method: "POST",
        body: JSON.stringify(data),
      });
    },
    /**
     * Delete product attributes metadata.
     * Remove product attribute metadata resources from the catalog data.
     * @param data - Array<FeedMetadataDelete> payload
     * @returns {Promise<ProcessFeedResponse>} feed response indicating the number of accepted items
     * @throws {Error} if the API request fails
     */
    async deleteProductMetadata(data: Array<FeedMetadataDelete>): Promise<ProcessFeedResponse> {
      return await http.request<ProcessFeedResponse>(`/v1/catalog/products/metadata/delete`, {
        method: "POST",
        body: JSON.stringify(data),
      });
    },
    /**
     * Update product attribute metadata.
     * Update existing product attribute metadata with new values. When the update is processed, the merge strategy is used to apply changes to `scalar` and `object` type fields. The replace strategy is used to apply changes for fields in an `array`. 
     * @param data - Array<FeedMetadataUpdate> payload
     * @returns {Promise<ProcessFeedResponse>} feed response indicating the number of accepted items
     * @throws {Error} if the API request fails
     */
    async updateProductMetadata(data: Array<FeedMetadataUpdate>): Promise<ProcessFeedResponse> {
      return await http.request<ProcessFeedResponse>(`/v1/catalog/products/metadata`, {
        method: "PATCH",
        body: JSON.stringify(data),
      });
    },
    /**
     * Create price books.
     * Create or replace existing price books.  Use the update operation to modify values for existing price books. 
     * @param data - Array<FeedPricebook> payload
     * @returns {Promise<ProcessFeedResponse>} feed response indicating the number of accepted items
     * @throws {Error} if the API request fails
     */
    async createPriceBooks(data: Array<FeedPricebook>): Promise<ProcessFeedResponse> {
      return await http.request<ProcessFeedResponse>(`/v1/catalog/price-books`, {
        method: "POST",
        body: JSON.stringify(data),
      });
    },
    /**
     * Delete price books.
     * Delete existing price books. Note that you cannot delete the default price book with id `main`. 
     * @param data - Array<FeedPricebook> payload
     * @returns {Promise<ProcessFeedResponse>} feed response indicating the number of accepted items
     * @throws {Error} if the API request fails
     */
    async deletePriceBooks(data: Array<FeedPricebook>): Promise<ProcessFeedResponse> {
      return await http.request<ProcessFeedResponse>(`/v1/catalog/price-books/delete`, {
        method: "POST",
        body: JSON.stringify(data),
      });
    },
    /**
     * Update price books.
     * Update existing price books to change the name or the currency used for pricing. When the update is processed, the merge strategy is used to apply changes to `scalar` and `object` type fields. The replace strategy is used to apply changes for fields in an `array`.  To update the currency for the default price book, use the price book id `main`.
     * @param data - Array<FeedPricebook> payload
     * @returns {Promise<ProcessFeedResponse>} feed response indicating the number of accepted items
     * @throws {Error} if the API request fails
     */
    async updatePricebooks(data: Array<FeedPricebook>): Promise<ProcessFeedResponse> {
      return await http.request<ProcessFeedResponse>(`/v1/catalog/price-books`, {
        method: "PATCH",
        body: JSON.stringify(data),
      });
    },
    /**
     * Create prices.
     * <h3>Simple Products</h3> Create or replace existing product prices.  A price must be associated with at least the default price book with id `main`.  <h3>Configurable Products</h3> Because configurable product price is calculated based on the price of the selected product variant, you don\'t need to send price data for configurable product skus. Sending price data for these skus can cause incorrect price calculations. 
     * @param data - Array<FeedPrices> payload
     * @returns {Promise<ProcessFeedResponse>} feed response indicating the number of accepted items
     * @throws {Error} if the API request fails
     */
    async createPrices(data: Array<FeedPrices>): Promise<ProcessFeedResponse> {
      return await http.request<ProcessFeedResponse>(`/v1/catalog/products/prices`, {
        method: "POST",
        body: JSON.stringify(data),
      });
    },
    /**
     * Delete prices.
     * Delete existing product prices 
     * @param data - Array<FeedPricesDelete> payload
     * @returns {Promise<ProcessFeedResponse>} feed response indicating the number of accepted items
     * @throws {Error} if the API request fails
     */
    async deletePrices(data: Array<FeedPricesDelete>): Promise<ProcessFeedResponse> {
      return await http.request<ProcessFeedResponse>(`/v1/catalog/products/prices/delete`, {
        method: "POST",
        body: JSON.stringify(data),
      });
    },
    /**
     * Update prices.
     * Change existing product prices. When the update is processed, the merge strategy is used to apply changes to `scalar` and `object` type fields. The replace strategy is used to apply changes for fields in an `array`. 
     * @param data - Array<FeedPricesUpdate> payload
     * @returns {Promise<ProcessFeedResponse>} feed response indicating the number of accepted items
     * @throws {Error} if the API request fails
     */
    async updatePrices(data: Array<FeedPricesUpdate>): Promise<ProcessFeedResponse> {
      return await http.request<ProcessFeedResponse>(`/v1/catalog/products/prices`, {
        method: "PATCH",
        body: JSON.stringify(data),
      });
    },
    /**
     * Create products.
     * <h3>Simple Products</h3> Create products or replace existing products with a specified `sku` and `scope`. If a product with the same data exists with the same SKU and scope, the product update request is ignored.  Use the [update operation](#operation/ProductsPatch) to modify values for an existing product.  <h3>Configurable Products</h3> A configurable product is a product that offers multiple options, such as color and size. Each unique combination of these options, like \'color green\' and \'size large,\' defines a product variant. This variant is an independent product with its own SKU, price, and inventory. The configurable product acts as a container for these product variants.  To create a configurable product, you need the following: - [Product attributes](#operation/ProductMetadataPut): Define the product attributes used to define a configurable product, such as \"color\", \"size\", etc. - [Configurable product](#operation/ProductsPost): Define the configurable product. [Options](#operation/ProductsPost!path=options&t=request) is a required field. It defines the choices that a shopper can select. - [Product variant](#operation/ProductsPost): Define a product variant for a configurable product. [\"Attributes\"](#operation/ProductsPost!path=attributes) with [\"variantReferenceId\"](#operation/ProductsPost!path=attributes/variantReferenceId&t=request) and [\"links\"](#operation/ProductsPost!path=links&t=request) of type `VARIANT_OF` must be defined for product variants.  Each product variant links back to the configurable product through its `variantReferenceId`, which corresponds to specific `options[].values[].id` in the configurable product.  To unassign a product variant from a configurable product, do one of the following: - Use [Delete Product API](#operation/ProductsDelete) to delete the product variant. - Use [Update Product API](#operation/ProductsPatch) to set the [\"variantReferenceId\"](#operation/ProductsPost!path=attributes/variantReferenceId&t=request) to `null` and unassign the product variant from the configurable product by removing the [\"links\"](#operation/ProductsPost!path=links&t=request) association. 
     * @param data - Array<FeedProduct> payload
     * @returns {Promise<ProcessFeedResponse>} feed response indicating the number of accepted items
     * @throws {Error} if the API request fails
     */
    async createProducts(data: Array<FeedProduct>): Promise<ProcessFeedResponse> {
      return await http.request<ProcessFeedResponse>(`/v1/catalog/products`, {
        method: "POST",
        body: JSON.stringify(data),
      });
    },
    /**
     * Delete products.
     * Delete products with specified \"sku\" and \"scope\". 
     * @param data - Array<FeedProductDelete> payload
     * @returns {Promise<ProcessFeedResponse>} feed response indicating the number of accepted items
     * @throws {Error} if the API request fails
     */
    async deleteProducts(data: Array<FeedProductDelete>): Promise<ProcessFeedResponse> {
      return await http.request<ProcessFeedResponse>(`/v1/catalog/products/delete`, {
        method: "POST",
        body: JSON.stringify(data),
      });
    },
    /**
     * Update products.
     * Update products with specified \"sku\" and \"scope\" to replace existing field data with the data supplied in the request. When the update is processed, the merge strategy is used to apply changes to `scalar` and `object` type fields. The replace strategy is used to apply changes for fields in an `array`. 
     * @param data - Array<FeedProductUpdate> payload
     * @returns {Promise<ProcessFeedResponse>} feed response indicating the number of accepted items
     * @throws {Error} if the API request fails
     */
    async updateProducts(data: Array<FeedProductUpdate>): Promise<ProcessFeedResponse> {
      return await http.request<ProcessFeedResponse>(`/v1/catalog/products`, {
        method: "PATCH",
        body: JSON.stringify(data),
      });
    },
  };
}

/**
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2025 Adobe All Rights Reserved.
 *
 * NOTICE: All information contained herein is, and remains the property of Adobe and its suppliers, if any. The
 * intellectual and technical concepts contained herein are proprietary to Adobe and its suppliers and are protected by
 * all applicable intellectual property laws, including trade secret and copyright laws. Dissemination of this
 * information or reproduction of this material is strictly forbidden unless prior written permission is obtained from
 * Adobe.
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech) using custom templates.
 * Generator configuration can be found in the /generator directory.
 *
 * Do not edit this file manually!
 */

import { describe, it, expect, vi, beforeEach, Mock } from 'vitest';
import { createClient } from '../src/client';
import { createHttpClient } from '../src/http-client';
import { createAuthService } from '../src/auth';

// Mock the dependencies
vi.mock('../src/http-client');
vi.mock('../src/auth');

describe('Client', () => {
  const mockCredentials = {
    clientId: 'test-client-id',
    clientSecret: 'test-client-secret',
    scopes: 'test-scopes',
  };
  const mockTenantId = 'test-tenant-id';
  const mockRegion = 'na1';
  const mockEnvironment = 'sandbox';

  const mockHttpClient = {
    request: vi.fn(),
  };

  beforeEach(() => {
    vi.clearAllMocks();
    (createHttpClient as Mock).mockReturnValue(mockHttpClient);
    (createAuthService as Mock).mockReturnValue({});
  });

  describe('createProductMetadata', () => {
    it('should call the correct endpoint with POST method', async () => {
      const client = createClient(mockCredentials, mockTenantId, mockRegion, mockEnvironment);
      const mockData = [{}];
      const mockResponse = { accepted: 1 };

      mockHttpClient.request.mockResolvedValue(mockResponse);

      // @ts-expect-error - Ignore type check warning
      const result = await client.createProductMetadata(mockData);

      expect(mockHttpClient.request).toHaveBeenCalledWith('/v1/catalog/products/metadata', {
        method: 'POST',
        body: JSON.stringify(mockData),
      });
      expect(result).toEqual(mockResponse);
    });
  });

  describe('deleteProductMetadata', () => {
    it('should call the correct endpoint with POST method', async () => {
      const client = createClient(mockCredentials, mockTenantId, mockRegion, mockEnvironment);
      const mockData = [{}];
      const mockResponse = { accepted: 1 };

      mockHttpClient.request.mockResolvedValue(mockResponse);

      // @ts-expect-error - Ignore type check warning
      const result = await client.deleteProductMetadata(mockData);

      expect(mockHttpClient.request).toHaveBeenCalledWith('/v1/catalog/products/metadata/delete', {
        method: 'POST',
        body: JSON.stringify(mockData),
      });
      expect(result).toEqual(mockResponse);
    });
  });

  describe('updateProductMetadata', () => {
    it('should call the correct endpoint with PATCH method', async () => {
      const client = createClient(mockCredentials, mockTenantId, mockRegion, mockEnvironment);
      const mockData = [{}];
      const mockResponse = { accepted: 1 };

      mockHttpClient.request.mockResolvedValue(mockResponse);

      // @ts-expect-error - Ignore type check warning
      const result = await client.updateProductMetadata(mockData);

      expect(mockHttpClient.request).toHaveBeenCalledWith('/v1/catalog/products/metadata', {
        method: 'PATCH',
        body: JSON.stringify(mockData),
      });
      expect(result).toEqual(mockResponse);
    });
  });

  describe('createPriceBooks', () => {
    it('should call the correct endpoint with POST method', async () => {
      const client = createClient(mockCredentials, mockTenantId, mockRegion, mockEnvironment);
      const mockData = [{}];
      const mockResponse = { accepted: 1 };

      mockHttpClient.request.mockResolvedValue(mockResponse);

      // @ts-expect-error - Ignore type check warning
      const result = await client.createPriceBooks(mockData);

      expect(mockHttpClient.request).toHaveBeenCalledWith('/v1/catalog/price-books', {
        method: 'POST',
        body: JSON.stringify(mockData),
      });
      expect(result).toEqual(mockResponse);
    });
  });

  describe('deletePriceBooks', () => {
    it('should call the correct endpoint with POST method', async () => {
      const client = createClient(mockCredentials, mockTenantId, mockRegion, mockEnvironment);
      const mockData = [{}];
      const mockResponse = { accepted: 1 };

      mockHttpClient.request.mockResolvedValue(mockResponse);

      // @ts-expect-error - Ignore type check warning
      const result = await client.deletePriceBooks(mockData);

      expect(mockHttpClient.request).toHaveBeenCalledWith('/v1/catalog/price-books/delete', {
        method: 'POST',
        body: JSON.stringify(mockData),
      });
      expect(result).toEqual(mockResponse);
    });
  });

  describe('updatePriceBooks', () => {
    it('should call the correct endpoint with PATCH method', async () => {
      const client = createClient(mockCredentials, mockTenantId, mockRegion, mockEnvironment);
      const mockData = [{}];
      const mockResponse = { accepted: 1 };

      mockHttpClient.request.mockResolvedValue(mockResponse);

      // @ts-expect-error - Ignore type check warning
      const result = await client.updatePriceBooks(mockData);

      expect(mockHttpClient.request).toHaveBeenCalledWith('/v1/catalog/price-books', {
        method: 'PATCH',
        body: JSON.stringify(mockData),
      });
      expect(result).toEqual(mockResponse);
    });
  });

  describe('createPrices', () => {
    it('should call the correct endpoint with POST method', async () => {
      const client = createClient(mockCredentials, mockTenantId, mockRegion, mockEnvironment);
      const mockData = [{}];
      const mockResponse = { accepted: 1 };

      mockHttpClient.request.mockResolvedValue(mockResponse);

      // @ts-expect-error - Ignore type check warning
      const result = await client.createPrices(mockData);

      expect(mockHttpClient.request).toHaveBeenCalledWith('/v1/catalog/products/prices', {
        method: 'POST',
        body: JSON.stringify(mockData),
      });
      expect(result).toEqual(mockResponse);
    });
  });

  describe('deletePrices', () => {
    it('should call the correct endpoint with POST method', async () => {
      const client = createClient(mockCredentials, mockTenantId, mockRegion, mockEnvironment);
      const mockData = [{}];
      const mockResponse = { accepted: 1 };

      mockHttpClient.request.mockResolvedValue(mockResponse);

      // @ts-expect-error - Ignore type check warning
      const result = await client.deletePrices(mockData);

      expect(mockHttpClient.request).toHaveBeenCalledWith('/v1/catalog/products/prices/delete', {
        method: 'POST',
        body: JSON.stringify(mockData),
      });
      expect(result).toEqual(mockResponse);
    });
  });

  describe('updatePrices', () => {
    it('should call the correct endpoint with PATCH method', async () => {
      const client = createClient(mockCredentials, mockTenantId, mockRegion, mockEnvironment);
      const mockData = [{}];
      const mockResponse = { accepted: 1 };

      mockHttpClient.request.mockResolvedValue(mockResponse);

      // @ts-expect-error - Ignore type check warning
      const result = await client.updatePrices(mockData);

      expect(mockHttpClient.request).toHaveBeenCalledWith('/v1/catalog/products/prices', {
        method: 'PATCH',
        body: JSON.stringify(mockData),
      });
      expect(result).toEqual(mockResponse);
    });
  });

  describe('createProducts', () => {
    it('should call the correct endpoint with POST method', async () => {
      const client = createClient(mockCredentials, mockTenantId, mockRegion, mockEnvironment);
      const mockData = [{}];
      const mockResponse = { accepted: 1 };

      mockHttpClient.request.mockResolvedValue(mockResponse);

      // @ts-expect-error - Ignore type check warning
      const result = await client.createProducts(mockData);

      expect(mockHttpClient.request).toHaveBeenCalledWith('/v1/catalog/products', {
        method: 'POST',
        body: JSON.stringify(mockData),
      });
      expect(result).toEqual(mockResponse);
    });
  });

  describe('deleteProducts', () => {
    it('should call the correct endpoint with POST method', async () => {
      const client = createClient(mockCredentials, mockTenantId, mockRegion, mockEnvironment);
      const mockData = [{}];
      const mockResponse = { accepted: 1 };

      mockHttpClient.request.mockResolvedValue(mockResponse);

      // @ts-expect-error - Ignore type check warning
      const result = await client.deleteProducts(mockData);

      expect(mockHttpClient.request).toHaveBeenCalledWith('/v1/catalog/products/delete', {
        method: 'POST',
        body: JSON.stringify(mockData),
      });
      expect(result).toEqual(mockResponse);
    });
  });

  describe('updateProducts', () => {
    it('should call the correct endpoint with PATCH method', async () => {
      const client = createClient(mockCredentials, mockTenantId, mockRegion, mockEnvironment);
      const mockData = [{}];
      const mockResponse = { accepted: 1 };

      mockHttpClient.request.mockResolvedValue(mockResponse);

      // @ts-expect-error - Ignore type check warning
      const result = await client.updateProducts(mockData);

      expect(mockHttpClient.request).toHaveBeenCalledWith('/v1/catalog/products', {
        method: 'PATCH',
        body: JSON.stringify(mockData),
      });
      expect(result).toEqual(mockResponse);
    });
  });
});

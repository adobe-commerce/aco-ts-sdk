/**
 * Copyright 2025 Adobe. All Rights Reserved.
 *
 * This file is licensed to you under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, either express or implied. See the License for
 * the specific language governing permissions and limitations under the License.
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech) using custom templates.
 * Generator configuration can be found in the /generator directory.
 *
 * Do not edit this file manually!
 */

import { describe, it, expect, vi, beforeEach, Mock } from 'vitest';
import { createClient } from '../../src/client';
import { createHttpClient } from '../../src/http-client';
import { createAuthService } from '../../src/auth';
import {
  ApiResponse,
  ClientConfig,
  FeedMetadataDataTypeEnum,
  FeedProductStatusEnum,
  FeedProductVisibleInEnum,
  FeedMetadataVisibleInEnum,
  ProductAttributeTypeEnum,
} from '../../src/types';

// Mock the dependencies
vi.mock('../../src/http-client');
vi.mock('../../src/auth');

describe('Client', () => {
  const mockCredentials = {
    clientId: 'test-client-id',
    clientSecret: 'test-client-secret',
    scopes: 'test-scopes',
  };
  const mockTenantId = 'test-tenant-id';
  const mockRegion = 'na1';
  const mockEnvironment = 'sandbox';

  const mockHttpClient = {
    request: vi.fn(),
  };

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const createMockData = (operationName: string): any[] => {
    const baseMock = {
      scope: { locale: 'en-US' },
    };

    switch (operationName) {
      case 'createProductMetadata':
      case 'updateProductMetadata':
        return [
          {
            ...baseMock,
            code: 'test-attribute',
            label: 'Test Attribute',
            dataType: FeedMetadataDataTypeEnum.Text,
            visibleIn: [FeedMetadataVisibleInEnum.ProductDetail],
            filterable: true,
            sortable: true,
            searchable: true,
            searchWeight: 1,
            searchTypes: ['AUTOCOMPLETE'],
          },
        ];

      case 'deleteProductMetadata':
        return [
          {
            ...baseMock,
            code: 'test-attribute',
          },
        ];

      case 'createProducts':
      case 'updateProducts':
        return [
          {
            ...baseMock,
            sku: 'test-sku',
            name: 'Test Product',
            slug: 'test-product',
            description: 'This is a test product created via the SDK',
            shortDescription: 'test product',
            status: FeedProductStatusEnum.Enabled,
            visibleIn: [FeedProductVisibleInEnum.Catalog, FeedProductVisibleInEnum.Search],
            attributes: [
              {
                code: 'brand',
                type: ProductAttributeTypeEnum.String,
                values: ['Test Brand'],
              },
              {
                code: 'category',
                type: ProductAttributeTypeEnum.String,
                values: ['Electronics'],
              },
            ],
            images: [
              {
                url: 'https://example.com/image.jpg',
                label: 'Test Product Image',
                roles: ['BASE', 'SMALL'],
                customRoles: ['widget'],
              },
            ],
            links: [
              {
                type: 'VARIANT_OF',
                sku: 'parent-product',
              },
            ],
            routes: [
              {
                path: 'path/to/test-sku',
                position: 2,
              },
            ],
          },
        ];

      case 'deleteProducts':
        return [
          {
            ...baseMock,
            sku: 'test-sku',
          },
        ];

      case 'createPrices':
      case 'updatePrices':
        return [
          {
            sku: 'test-sku',
            priceBookId: 'test-pricebook',
            price: 99.99,
          },
        ];

      case 'deletePrices':
        return [
          {
            sku: 'test-sku',
            priceBookId: 'test-pricebook',
          },
        ];

      case 'createPriceBooks':
      case 'updatePriceBooks':
      case 'deletePriceBooks':
        return [
          {
            priceBookId: 'test-pricebook',
            name: 'Test Price Book',
            currency: 'USD',
          },
        ];

      default:
        return [{}];
    }
  };

  beforeEach(() => {
    vi.clearAllMocks();
    (createHttpClient as Mock).mockReturnValue(mockHttpClient);
    (createAuthService as Mock).mockReturnValue({});
  });

  describe('createProductMetadata', () => {
    it('should call the correct endpoint with POST method', async () => {
      const config: ClientConfig = {
        credentials: mockCredentials,
        tenantId: mockTenantId,
        region: mockRegion,
        environment: mockEnvironment,
      };
      const client = createClient(config);
      const mockData = createMockData('createProductMetadata');
      const mockResponse: ApiResponse = {
        ok: true,
        status: 200,
        statusText: 'OK',
        data: {
          status: 'ACCEPTED',
          acceptedCount: 1,
        },
      };

      mockHttpClient.request.mockResolvedValue(mockResponse);

      const result = await client.createProductMetadata(mockData);

      expect(mockHttpClient.request).toHaveBeenCalledWith('/v1/catalog/products/metadata', {
        method: 'POST',
        body: JSON.stringify(mockData),
      });
      expect(result).toEqual(mockResponse);
    });
  });

  describe('deleteProductMetadata', () => {
    it('should call the correct endpoint with POST method', async () => {
      const config: ClientConfig = {
        credentials: mockCredentials,
        tenantId: mockTenantId,
        region: mockRegion,
        environment: mockEnvironment,
      };
      const client = createClient(config);
      const mockData = createMockData('deleteProductMetadata');
      const mockResponse: ApiResponse = {
        ok: true,
        status: 200,
        statusText: 'OK',
        data: {
          status: 'ACCEPTED',
          acceptedCount: 1,
        },
      };

      mockHttpClient.request.mockResolvedValue(mockResponse);

      const result = await client.deleteProductMetadata(mockData);

      expect(mockHttpClient.request).toHaveBeenCalledWith('/v1/catalog/products/metadata/delete', {
        method: 'POST',
        body: JSON.stringify(mockData),
      });
      expect(result).toEqual(mockResponse);
    });
  });

  describe('updateProductMetadata', () => {
    it('should call the correct endpoint with PATCH method', async () => {
      const config: ClientConfig = {
        credentials: mockCredentials,
        tenantId: mockTenantId,
        region: mockRegion,
        environment: mockEnvironment,
      };
      const client = createClient(config);
      const mockData = createMockData('updateProductMetadata');
      const mockResponse: ApiResponse = {
        ok: true,
        status: 200,
        statusText: 'OK',
        data: {
          status: 'ACCEPTED',
          acceptedCount: 1,
        },
      };

      mockHttpClient.request.mockResolvedValue(mockResponse);

      const result = await client.updateProductMetadata(mockData);

      expect(mockHttpClient.request).toHaveBeenCalledWith('/v1/catalog/products/metadata', {
        method: 'PATCH',
        body: JSON.stringify(mockData),
      });
      expect(result).toEqual(mockResponse);
    });
  });

  describe('createPriceBooks', () => {
    it('should call the correct endpoint with POST method', async () => {
      const config: ClientConfig = {
        credentials: mockCredentials,
        tenantId: mockTenantId,
        region: mockRegion,
        environment: mockEnvironment,
      };
      const client = createClient(config);
      const mockData = createMockData('createPriceBooks');
      const mockResponse: ApiResponse = {
        ok: true,
        status: 200,
        statusText: 'OK',
        data: {
          status: 'ACCEPTED',
          acceptedCount: 1,
        },
      };

      mockHttpClient.request.mockResolvedValue(mockResponse);

      const result = await client.createPriceBooks(mockData);

      expect(mockHttpClient.request).toHaveBeenCalledWith('/v1/catalog/price-books', {
        method: 'POST',
        body: JSON.stringify(mockData),
      });
      expect(result).toEqual(mockResponse);
    });
  });

  describe('deletePriceBooks', () => {
    it('should call the correct endpoint with POST method', async () => {
      const config: ClientConfig = {
        credentials: mockCredentials,
        tenantId: mockTenantId,
        region: mockRegion,
        environment: mockEnvironment,
      };
      const client = createClient(config);
      const mockData = createMockData('deletePriceBooks');
      const mockResponse: ApiResponse = {
        ok: true,
        status: 200,
        statusText: 'OK',
        data: {
          status: 'ACCEPTED',
          acceptedCount: 1,
        },
      };

      mockHttpClient.request.mockResolvedValue(mockResponse);

      const result = await client.deletePriceBooks(mockData);

      expect(mockHttpClient.request).toHaveBeenCalledWith('/v1/catalog/price-books/delete', {
        method: 'POST',
        body: JSON.stringify(mockData),
      });
      expect(result).toEqual(mockResponse);
    });
  });

  describe('updatePriceBooks', () => {
    it('should call the correct endpoint with PATCH method', async () => {
      const config: ClientConfig = {
        credentials: mockCredentials,
        tenantId: mockTenantId,
        region: mockRegion,
        environment: mockEnvironment,
      };
      const client = createClient(config);
      const mockData = createMockData('updatePriceBooks');
      const mockResponse: ApiResponse = {
        ok: true,
        status: 200,
        statusText: 'OK',
        data: {
          status: 'ACCEPTED',
          acceptedCount: 1,
        },
      };

      mockHttpClient.request.mockResolvedValue(mockResponse);

      const result = await client.updatePriceBooks(mockData);

      expect(mockHttpClient.request).toHaveBeenCalledWith('/v1/catalog/price-books', {
        method: 'PATCH',
        body: JSON.stringify(mockData),
      });
      expect(result).toEqual(mockResponse);
    });
  });

  describe('createPrices', () => {
    it('should call the correct endpoint with POST method', async () => {
      const config: ClientConfig = {
        credentials: mockCredentials,
        tenantId: mockTenantId,
        region: mockRegion,
        environment: mockEnvironment,
      };
      const client = createClient(config);
      const mockData = createMockData('createPrices');
      const mockResponse: ApiResponse = {
        ok: true,
        status: 200,
        statusText: 'OK',
        data: {
          status: 'ACCEPTED',
          acceptedCount: 1,
        },
      };

      mockHttpClient.request.mockResolvedValue(mockResponse);

      const result = await client.createPrices(mockData);

      expect(mockHttpClient.request).toHaveBeenCalledWith('/v1/catalog/products/prices', {
        method: 'POST',
        body: JSON.stringify(mockData),
      });
      expect(result).toEqual(mockResponse);
    });
  });

  describe('deletePrices', () => {
    it('should call the correct endpoint with POST method', async () => {
      const config: ClientConfig = {
        credentials: mockCredentials,
        tenantId: mockTenantId,
        region: mockRegion,
        environment: mockEnvironment,
      };
      const client = createClient(config);
      const mockData = createMockData('deletePrices');
      const mockResponse: ApiResponse = {
        ok: true,
        status: 200,
        statusText: 'OK',
        data: {
          status: 'ACCEPTED',
          acceptedCount: 1,
        },
      };

      mockHttpClient.request.mockResolvedValue(mockResponse);

      const result = await client.deletePrices(mockData);

      expect(mockHttpClient.request).toHaveBeenCalledWith('/v1/catalog/products/prices/delete', {
        method: 'POST',
        body: JSON.stringify(mockData),
      });
      expect(result).toEqual(mockResponse);
    });
  });

  describe('updatePrices', () => {
    it('should call the correct endpoint with PATCH method', async () => {
      const config: ClientConfig = {
        credentials: mockCredentials,
        tenantId: mockTenantId,
        region: mockRegion,
        environment: mockEnvironment,
      };
      const client = createClient(config);
      const mockData = createMockData('updatePrices');
      const mockResponse: ApiResponse = {
        ok: true,
        status: 200,
        statusText: 'OK',
        data: {
          status: 'ACCEPTED',
          acceptedCount: 1,
        },
      };

      mockHttpClient.request.mockResolvedValue(mockResponse);

      const result = await client.updatePrices(mockData);

      expect(mockHttpClient.request).toHaveBeenCalledWith('/v1/catalog/products/prices', {
        method: 'PATCH',
        body: JSON.stringify(mockData),
      });
      expect(result).toEqual(mockResponse);
    });
  });

  describe('createProducts', () => {
    it('should call the correct endpoint with POST method', async () => {
      const config: ClientConfig = {
        credentials: mockCredentials,
        tenantId: mockTenantId,
        region: mockRegion,
        environment: mockEnvironment,
      };
      const client = createClient(config);
      const mockData = createMockData('createProducts');
      const mockResponse: ApiResponse = {
        ok: true,
        status: 200,
        statusText: 'OK',
        data: {
          status: 'ACCEPTED',
          acceptedCount: 1,
        },
      };

      mockHttpClient.request.mockResolvedValue(mockResponse);

      const result = await client.createProducts(mockData);

      expect(mockHttpClient.request).toHaveBeenCalledWith('/v1/catalog/products', {
        method: 'POST',
        body: JSON.stringify(mockData),
      });
      expect(result).toEqual(mockResponse);
    });
  });

  describe('deleteProducts', () => {
    it('should call the correct endpoint with POST method', async () => {
      const config: ClientConfig = {
        credentials: mockCredentials,
        tenantId: mockTenantId,
        region: mockRegion,
        environment: mockEnvironment,
      };
      const client = createClient(config);
      const mockData = createMockData('deleteProducts');
      const mockResponse: ApiResponse = {
        ok: true,
        status: 200,
        statusText: 'OK',
        data: {
          status: 'ACCEPTED',
          acceptedCount: 1,
        },
      };

      mockHttpClient.request.mockResolvedValue(mockResponse);

      const result = await client.deleteProducts(mockData);

      expect(mockHttpClient.request).toHaveBeenCalledWith('/v1/catalog/products/delete', {
        method: 'POST',
        body: JSON.stringify(mockData),
      });
      expect(result).toEqual(mockResponse);
    });
  });

  describe('updateProducts', () => {
    it('should call the correct endpoint with PATCH method', async () => {
      const config: ClientConfig = {
        credentials: mockCredentials,
        tenantId: mockTenantId,
        region: mockRegion,
        environment: mockEnvironment,
      };
      const client = createClient(config);
      const mockData = createMockData('updateProducts');
      const mockResponse: ApiResponse = {
        ok: true,
        status: 200,
        statusText: 'OK',
        data: {
          status: 'ACCEPTED',
          acceptedCount: 1,
        },
      };

      mockHttpClient.request.mockResolvedValue(mockResponse);

      const result = await client.updateProducts(mockData);

      expect(mockHttpClient.request).toHaveBeenCalledWith('/v1/catalog/products', {
        method: 'PATCH',
        body: JSON.stringify(mockData),
      });
      expect(result).toEqual(mockResponse);
    });
  });
});
